import{j as p}from"./jsx-runtime-DEdD30eg.js";function d({name:i,list:s,type:a,min:r,max:u,defaultValue:m,valueRef:e,onChange:n}){const l=o=>{const t=o.target.value;e&&(e.current=t),n==null||n(t)};return p.jsx("input",{className:"faceplate-input",type:a,name:i,min:r,max:u,list:s,defaultValue:m||(e==null?void 0:e.current),onChange:l})}d.__docgenInfo={description:`This is a simplified input component. It works like a regular input element,
 but exposes less of the API of the regular input. This is done so that the API
 can be simplified. For example, the onChange() provides changed value instead 
 of instance of change event. In most cases this is perfectly fine.`,methods:[],displayName:"Input",props:{name:{required:!0,tsType:{name:"string"},description:"The name of the input."},list:{required:!1,tsType:{name:"string"},description:"The HTML id of a list of suggestions for text/number fields."},type:{required:!1,tsType:{name:"union",raw:'"number" | "text"',elements:[{name:"literal",value:'"number"'},{name:"literal",value:'"text"'}]},description:"Type of the input."},min:{required:!1,tsType:{name:"union",raw:"number | string",elements:[{name:"number"},{name:"string"}]},description:'The minimal value. It makes only sense for "number" inputs.'},max:{required:!1,tsType:{name:"union",raw:"number | string",elements:[{name:"number"},{name:"string"}]},description:'The maximal value. It makes only sense for "number" inputs.'},defaultValue:{required:!1,tsType:{name:"union",raw:"string | number",elements:[{name:"string"},{name:"number"}]},description:"The default value of the input."},valueRef:{required:!1,tsType:{name:"MutableRefObject",elements:[{name:"string"}],raw:"MutableRefObject<string>"},description:"A mutable ref to the input value."},onChange:{required:!1,tsType:{name:"signature",type:"function",raw:"(value: string) => void",signature:{arguments:[{type:{name:"string"},name:"value"}],return:{name:"void"}}},description:"A callback to call when user changed the value."}}};export{d as I};
